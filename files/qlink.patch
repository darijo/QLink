diff -Naur mininet/net.py mininet/net.py
--- mininet/net.py	2022-02-01 13:22:37.200050000 +0100
+++ mininet/net.py	2022-01-05 14:53:16.000000000 +0100
@@ -99,28 +99,28 @@
 
 from mininet.cli import CLI
 from mininet.log import info, error, debug, output, warn
-from mininet.node import ( Node, Host, OVSKernelSwitch, DefaultController,
-                           Controller )
+from mininet.node import (Node, Host, OVSKernelSwitch, DefaultController,
+                          Controller)
 from mininet.nodelib import NAT
 from mininet.link import Link, Intf
-from mininet.util import ( quietRun, fixLimits, numCores, ensureRoot,
-                           macColonHex, ipStr, ipParse, netParse, ipAdd,
-                           waitListening, BaseString )
+from mininet.util import (quietRun, fixLimits, numCores, ensureRoot,
+                          macColonHex, ipStr, ipParse, netParse, ipAdd,
+                          waitListening, BaseString)
 from mininet.term import cleanUpScreens, makeTerms
 
 # Mininet version: should be consistent with README and LICENSE
 VERSION = "2.3.0"
 
-class Mininet( object ):
+class Mininet(object):
     "Network emulation with hosts spawned in network namespaces."
 
     # pylint: disable=too-many-arguments
-    def __init__( self, topo=None, switch=OVSKernelSwitch, host=Host,
-                  controller=DefaultController, link=Link, intf=Intf,
-                  build=True, xterms=False, cleanup=False, ipBase='10.0.0.0/8',
-                  inNamespace=False,
-                  autoSetMacs=False, autoStaticArp=False, autoPinCpus=False,
-                  listenPort=None, waitConnected=False ):
+    def __init__(self, topo=None, switch=OVSKernelSwitch, host=Host,
+                 controller=DefaultController, link=Link, intf=Intf,
+                 build=True, xterms=False, cleanup=False, ipBase='10.0.0.0/8',
+                 inNamespace=False,
+                 autoSetMacs=False, autoStaticArp=False, autoPinCpus=False,
+                 listenPort=None, waitConnected=False):
         """Create Mininet object.
            topo: Topo (topology) object or None
            switch: default Switch class
@@ -147,8 +147,8 @@
         self.link = link
         self.intf = intf
         self.ipBase = ipBase
-        self.ipBaseNum, self.prefixLen = netParse( self.ipBase )
-        hostIP = ( 0xffffffff >> self.prefixLen ) & self.ipBaseNum
+        self.ipBaseNum, self.prefixLen = netParse(self.ipBase)
+        hostIP = (0xffffffff >> self.prefixLen) & self.ipBaseNum
         # Start for address allocation
         self.nextIP = hostIP if hostIP > 0 else 1
         self.inNamespace = inNamespace
@@ -169,6 +169,13 @@
 
         self.nameToNode = {}  # name to Node (Host/Switch) objects
 
+        ############################### Meghana change start ###############################
+        self.qosUuid = []
+        self.hiddenSwitchList = []
+        self.qintf = []
+        self.qparams = {}
+        ############################### Meghana change end ###############################
+
         self.terms = []  # list of spawned xterm processes
 
         Mininet.init()  # Initialize Mininet if necessary
@@ -177,209 +184,226 @@
         if topo and build:
             self.build()
 
-    def waitConnected( self, timeout=None, delay=.5 ):
+        ############################### Meghana change start ###############################
+        self.hiddenSwitches = 0
+        self.queuecount = 0
+        ############################### Meghana change end ###############################
+
+    def waitConnected(self, timeout=None, delay=.5):
         """wait for each switch to connect to a controller
            timeout: time to wait, or None or True to wait indefinitely
            delay: seconds to sleep per iteration
            returns: True if all switches are connected"""
-        info( '*** Waiting for switches to connect\n' )
+        info('*** Waiting for switches to connect\n')
         time = 0.0
-        remaining = list( self.switches )
+        remaining = list(self.switches)
         # False: 0s timeout; None: wait forever (preserve 2.2 behavior)
-        if isinstance( timeout, bool ):
+        if isinstance(timeout, bool):
             timeout = None if timeout else 0
         while True:
-            for switch in tuple( remaining ):
+            for switch in tuple(remaining):
                 if switch.connected():
-                    info( '%s ' % switch )
-                    remaining.remove( switch )
+                    info('%s ' % switch)
+                    remaining.remove(switch)
             if not remaining:
-                info( '\n' )
+                info('\n')
                 return True
             if timeout is not None and time >= timeout:
                 break
-            sleep( delay )
+            sleep(delay)
             time += delay
-        warn( 'Timed out after %d seconds\n' % time )
+        warn('Timed out after %d seconds\n' % time)
         for switch in remaining:
             if not switch.connected():
-                warn( 'Warning: %s is not connected to a controller\n'
-                      % switch.name )
+                warn('Warning: %s is not connected to a controller\n'
+                     % switch.name)
             else:
-                remaining.remove( switch )
+                remaining.remove(switch)
         return not remaining
 
-    def addHost( self, name, cls=None, **params ):
+    def addHost(self, name, cls=None, **params):
         """Add host.
            name: name of host to add
            cls: custom host class/constructor (optional)
            params: parameters for host
            returns: added host"""
         # Default IP and MAC addresses
-        defaults = { 'ip': ipAdd( self.nextIP,
-                                  ipBaseNum=self.ipBaseNum,
-                                  prefixLen=self.prefixLen ) +
-                                  '/%s' % self.prefixLen }
+        defaults = {'ip': ipAdd(self.nextIP,
+                                ipBaseNum=self.ipBaseNum,
+                                prefixLen=self.prefixLen) +
+                          '/%s' % self.prefixLen}
         if self.autoSetMacs:
-            defaults[ 'mac' ] = macColonHex( self.nextIP )
+            defaults['mac'] = macColonHex(self.nextIP)
         if self.autoPinCpus:
-            defaults[ 'cores' ] = self.nextCore
-            self.nextCore = ( self.nextCore + 1 ) % self.numCores
+            defaults['cores'] = self.nextCore
+            self.nextCore = (self.nextCore + 1) % self.numCores
         self.nextIP += 1
-        defaults.update( params )
+        defaults.update(params)
         if not cls:
             cls = self.host
-        h = cls( name, **defaults )
-        self.hosts.append( h )
-        self.nameToNode[ name ] = h
+        h = cls(name, **defaults)
+        self.hosts.append(h)
+        self.nameToNode[name] = h
         return h
 
-    def delNode( self, node, nodes=None):
+    def delNode(self, node, nodes=None):
         """Delete node
            node: node to delete
            nodes: optional list to delete from (e.g. self.hosts)"""
         if nodes is None:
-            nodes = ( self.hosts if node in self.hosts else
-                      ( self.switches if node in self.switches else
-                        ( self.controllers if node in self.controllers else
-                          [] ) ) )
-        node.stop( deleteIntfs=True )
+            nodes = (self.hosts if node in self.hosts else
+                     (self.switches if node in self.switches else
+                      (self.controllers if node in self.controllers else
+                       (self.hiddenSwitchList if node in self.hiddenSwitchList else
+                        []))))
+        node.stop(deleteIntfs=True)
         node.terminate()
-        nodes.remove( node )
-        del self.nameToNode[ node.name ]
+        nodes.remove(node)
+        del self.nameToNode[node.name]
 
-    def delHost( self, host ):
+    def delHost(self, host):
         "Delete a host"
-        self.delNode( host, nodes=self.hosts )
+        self.delNode(host, nodes=self.hosts)
 
-    def addSwitch( self, name, cls=None, **params ):
+    def addSwitch(self, name, cls=None, **params):
         """Add switch.
            name: name of switch to add
            cls: custom switch class/constructor (optional)
            returns: added switch
            side effect: increments listenPort ivar ."""
-        defaults = { 'listenPort': self.listenPort,
-                     'inNamespace': self.inNamespace }
-        defaults.update( params )
+        defaults = {'listenPort': self.listenPort,
+                    'inNamespace': self.inNamespace}
+        defaults.update(params)
         if not cls:
             cls = self.switch
-        sw = cls( name, **defaults )
         if not self.inNamespace and self.listenPort:
             self.listenPort += 1
-        self.switches.append( sw )
-        self.nameToNode[ name ] = sw
+
+        ############################### Meghana change start ###############################
+        sw = cls(name, **defaults)
+        if name[0:5] == 'stemp':            
+            self.hiddenSwitchList.append(sw)
+        else:        
+            self.switches.append(sw)
+        self.nameToNode[name] = sw
         return sw
+        ############################### Meghana change end ###############################
 
-    def delSwitch( self, switch ):
-        "Delete a switch"
-        self.delNode( switch, nodes=self.switches )
+    def delSwitch(self, switch):
+        """Delete a switch.
+            switches: name of switch
+            hiddenSwitchList: name of temporary switch"""
+        self.delNode(switch, nodes=self.switches)
+        ############################### Meghana change start ###############################
+        self.delNode(switch, nodes=self.hiddenSwitchList)
+        ############################### Meghana change end ###############################
 
-    def addController( self, name='c0', controller=None, **params ):
+    def addController(self, name='c0', controller=None, **params):
         """Add controller.
            controller: Controller class"""
         # Get controller class
         if not controller:
             controller = self.controller
         # Construct new controller if one is not given
-        if isinstance( name, Controller ):
+        if isinstance(name, Controller):
             controller_new = name
             # Pylint thinks controller is a str()
             # pylint: disable=maybe-no-member
             name = controller_new.name
             # pylint: enable=maybe-no-member
         else:
-            controller_new = controller( name, **params )
+            controller_new = controller(name, **params)
         # Add new controller to net
         if controller_new:  # allow controller-less setups
-            self.controllers.append( controller_new )
-            self.nameToNode[ name ] = controller_new
+            self.controllers.append(controller_new)
+            self.nameToNode[name] = controller_new
         return controller_new
 
-    def delController( self, controller ):
+    def delController(self, controller):
         """Delete a controller
            Warning - does not reconfigure switches, so they
            may still attempt to connect to it!"""
-        self.delNode( controller )
+        self.delNode(controller)
 
-    def addNAT( self, name='nat0', connect=True, inNamespace=False,
-                **params):
+    def addNAT(self, name='nat0', connect=True, inNamespace=False,
+               **params):
         """Add a NAT to the Mininet network
            name: name of NAT node
            connect: switch to connect to | True (s1) | None
            inNamespace: create in a network namespace
            params: other NAT node params, notably:
                ip: used as default gateway address"""
-        nat = self.addHost( name, cls=NAT, inNamespace=inNamespace,
-                            subnet=self.ipBase, **params )
+        nat = self.addHost(name, cls=NAT, inNamespace=inNamespace,
+                           subnet=self.ipBase, **params)
         # find first switch and create link
         if connect:
-            if not isinstance( connect, Node ):
+            if not isinstance(connect, Node):
                 # Use first switch if not specified
-                connect = self.switches[ 0 ]
+                connect = self.switches[0]
             # Connect the nat to the switch
-            self.addLink( nat, connect )
+            self.addLink(nat, connect)
             # Set the default route on hosts
-            natIP = nat.params[ 'ip' ].split('/')[ 0 ]
+            natIP = nat.params['ip'].split('/')[0]
             for host in self.hosts:
                 if host.inNamespace:
-                    host.setDefaultRoute( 'via %s' % natIP )
+                    host.setDefaultRoute('via %s' % natIP)
         return nat
 
     # BL: We now have four ways to look up nodes
     # This may (should?) be cleaned up in the future.
-    def getNodeByName( self, *args ):
+    def getNodeByName(self, *args):
         "Return node(s) with given name(s)"
-        if len( args ) == 1:
-            return self.nameToNode[ args[ 0 ] ]
-        return [ self.nameToNode[ n ] for n in args ]
+        if len(args) == 1:
+            return self.nameToNode[args[0]]
+        return [self.nameToNode[n] for n in args]
 
-    def get( self, *args ):
+    def get(self, *args):
         "Convenience alias for getNodeByName"
-        return self.getNodeByName( *args )
+        return self.getNodeByName(*args)
 
     # Even more convenient syntax for node lookup and iteration
-    def __getitem__( self, key ):
+    def __getitem__(self, key):
         "net[ name ] operator: Return node with given name"
-        return self.nameToNode[ key ]
+        return self.nameToNode[key]
 
-    def __delitem__( self, key ):
+    def __delitem__(self, key):
         "del net[ name ] operator - delete node with given name"
-        self.delNode( self.nameToNode[ key ] )
+        self.delNode(self.nameToNode[key])
 
-    def __iter__( self ):
+    def __iter__(self):
         "return iterator over node names"
-        for node in chain( self.hosts, self.switches, self.controllers ):
+        for node in chain(self.hosts, self.switches, self.controllers):
             yield node.name
 
-    def __len__( self ):
+    def __len__(self):
         "returns number of nodes in net"
-        return ( len( self.hosts ) + len( self.switches ) +
-                 len( self.controllers ) )
+        return (len(self.hosts) + len(self.switches) +
+                len(self.controllers))
 
-    def __contains__( self, item ):
+    def __contains__(self, item):
         "returns True if net contains named node"
         return item in self.nameToNode
 
-    def keys( self ):
+    def keys(self):
         "return a list of all node names or net's keys"
-        return list( self )
+        return list(self)
 
-    def values( self ):
+    def values(self):
         "return a list of all nodes or net's values"
-        return [ self[name] for name in self ]
+        return [self[name] for name in self]
 
-    def items( self ):
+    def items(self):
         "return (key,value) tuple list for every node in net"
-        return zip( self.keys(), self.values() )
+        return zip(self.keys(), self.values())
 
     @staticmethod
     def randMac():
         "Return a random, non-multicast MAC address"
-        return macColonHex( random.randint(1, 2**48 - 1) & 0xfeffffffffff |
-                            0x020000000000 )
+        return macColonHex(random.randint(1, 2 ** 48 - 1) & 0xfeffffffffff |
+                           0x020000000000)
 
-    def addLink( self, node1, node2, port1=None, port2=None,
-                 cls=None, **params ):
+    def addLink(self, node1, node2, port1=None, port2=None,
+                cls=None, **params):
         """"Add a link from node1 to node2
             node1: source node (or name)
             node2: dest node (or name)
@@ -389,67 +413,206 @@
             params: additional link params (optional)
             returns: link object"""
         # Accept node objects or names
-        node1 = node1 if not isinstance( node1, BaseString ) else self[ node1 ]
-        node2 = node2 if not isinstance( node2, BaseString ) else self[ node2 ]
-        options = dict( params )
+        node1 = node1 if not isinstance(node1, BaseString) else self[node1]
+        node2 = node2 if not isinstance(node2, BaseString) else self[node2]
+        options = dict(params)
         # Port is optional
         if port1 is not None:
-            options.setdefault( 'port1', port1 )
+            options.setdefault('port1', port1)
         if port2 is not None:
-            options.setdefault( 'port2', port2 )
+            options.setdefault('port2', port2)
         if self.intf is not None:
-            options.setdefault( 'intf', self.intf )
+            options.setdefault('intf', self.intf)
         # Set default MAC - this should probably be in Link
-        options.setdefault( 'addr1', self.randMac() )
-        options.setdefault( 'addr2', self.randMac() )
+        options.setdefault('addr1', self.randMac())
+        options.setdefault('addr2', self.randMac())
         cls = self.link if cls is None else cls
-        link = cls( node1, node2, **options )
-        self.links.append( link )
+        link = cls(node1, node2, **options)
+        self.links.append(link)
         return link
 
-    def delLink( self, link ):
+    def delLink(self, link):
         "Remove a link from this network"
         link.delete()
-        self.links.remove( link )
+        self.links.remove(link)
 
-    def linksBetween( self, node1, node2 ):
+    def linksBetween(self, node1, node2):
         "Return Links between node1 and node2"
-        return [ link for link in self.links
-                 if ( node1, node2 ) in (
-                    ( link.intf1.node, link.intf2.node ),
-                    ( link.intf2.node, link.intf1.node ) ) ]
+        return [link for link in self.links
+                if (node1, node2) in (
+                    (link.intf1.node, link.intf2.node),
+                    (link.intf2.node, link.intf1.node))]
 
-    def delLinkBetween( self, node1, node2, index=0, allLinks=False ):
+    def delLinkBetween(self, node1, node2, index=0, allLinks=False):
         """Delete link(s) between node1 and node2
            index: index of link to delete if multiple links (0)
            allLinks: ignore index and delete all such links (False)
            returns: deleted link(s)"""
-        links = self.linksBetween( node1, node2 )
+        links = self.linksBetween(node1, node2)
         if not allLinks:
-            links = [ links[ index ] ]
+            links = [links[index]]
         for link in links:
-            self.delLink( link )
+            self.delLink(link)
         return links
 
-    def configHosts( self ):
+    def configHosts(self):
         "Configure a set of hosts."
         for host in self.hosts:
-            info( host.name + ' ' )
+            info(host.name + ' ')
             intf = host.defaultIntf()
             if intf:
                 host.configDefault()
             else:
                 # Don't configure nonexistent intf
-                host.configDefault( ip=None, mac=None )
+                host.configDefault(ip=None, mac=None)
             # You're low priority, dude!
             # BL: do we want to do this here or not?
             # May not make sense if we have CPU lmiting...
             # quietRun( 'renice +18 -p ' + repr( host.pid ) )
             # This may not be the right place to do this, but
             # it needs to be done somewhere.
-        info( '\n' )
+        info('\n')
+
+    ############################### Meghana change start ###############################
+    def addQSpec(self, queue, priority, minRate, maxRate, **params):
+        """Maintain dictonary for queue params"""
+        qspec = {}
+        qspec['queue'] = queue
+        qspec['priority'] = priority
+        qspec['minRate'] = minRate
+        qspec['maxRate'] = maxRate
+        params = dict(params) if params else {}
+        qspec.update(params)
+        return qspec
+
+
+    def addQlink(self, node1, node2, params1, params2, qspec1=None, qspec2=None, **params):
+        """Create links with intermediate switch to introduce delay on switch interface"""
+        from mininet.link import TCULink
+        self.hiddenSwitches += 1
+        tswitch = 'stemp' + str(self.hiddenSwitches)
+        st = self.addSwitch(name=tswitch)
+        # Applying QoS link parameters such as bandwidth and delay to the respective interface
+        bwParamMax = 1000
+        params1 = dict( params1 ) if params1 else {}
+        params2 = dict( params2 ) if params2 else {}
+        params1.update( params )
+        params2.update( params )
+        #params1 = dict(params1) 
+        #params2 = dict(params2) 
+        bw1 = params1['bw']  * 2 if ('bw' in params1) else bwParamMax #[Zahran] - updated - not robust to user error  
+        bw2 = params2['bw']  * 2 if ('bw' in params1) else bwParamMax
+        if bw1 and (bw1 <= 0 or bw1 > bwParamMax):
+            error('Bandwidth limit for bw1: ', bw1, 'is outside supported range 0..%d' % bwParamMax, '- ignoring\n' )
+        else:
+            params1['bw'] = bw1
+
+        if bw2 and (bw2 <= 0 or bw2 > bwParamMax):
+            error('Bandwidth limit for bw2: ', bw2, 'is outside supported range 0..%d' % bwParamMax, '- ignoring\n' )
+        else:
+            params2['bw'] = bw2
+
+        addlink1 = self.addLink(node1, st, cls=TCULink, params1={}, params2=params1)
+        if str(addlink1.intf1)[0] == 's':    # if it is a switch, Install queues   [Zahran] - recommend generalize for s or S 
+            self.qintf.append(addlink1.intf1)
+            self.qparams[addlink1.intf1] = [qspec1, bw1] # add qparam to the interface dict.  [Zahran] updated - bw1 or 2*bw1
+            node1.hasQlink = True
+
+        addlink2 = self.addLink(st, node2, cls=TCULink, params1=params2, params2={})
+        if str(addlink2.intf2)[0] == 's':
+            self.qintf.append(addlink2.intf2)
+            self.qparams[addlink2.intf2] = [qspec2, bw2]  # add qparam to the interface dict.
+            node2.hasQlink = True
+
+        # Run temp switch in standalone mode
+        for tsw in self.hiddenSwitchList:
+            tsw.cmdPrint('sudo ovs-vsctl set-fail-mode ' + str(tsw) + ' standalone')
+
+    def __qosSwitch(self, node, intf):
+        """Create QoS on switches"""
+        qparams = self.qparams
+        qspecs, bw = qparams[intf]
+        if len(qspecs) < 1: 
+            return
+        queues = []
+        maxRates = []
+        minRates = []
+        priorities = []
+        for qspec in qspecs:
+            if 'queue' in qspec:
+                maxqueue = 967
+                queue = qspec['queue']
+                if queue and (queue < 0 or queue > maxqueue):
+                    error('Queue Length limit ', queue, ' is outside supported range 0..%d' % maxqueue, '- ignoring\n')
+            else:
+                queue = 0
+            queues.append(queue)
+            if 'priority' in qspec:
+                maxpriority = 8
+                priority = qspec['priority']
+                if priority and (priority < 1 or priority > maxpriority):
+                    error('Priority limit ', priority, ' is outside supported range 0..%d' % maxpriority, '- ignoring\n')
+            else:
+                priority = 8 # [zahran] updated to be the lowest priority 
+            priorities.append(priority)
 
-    def buildFromTopo( self, topo=None ):
+            if 'maxRate' in qspec:
+                maxRate = qspec['maxRate']
+                if maxRate and (maxRate < 0 or maxRate > 1):
+                    error('Given maxRate ', maxRate, ' is outside supported range 0..%d' % 1, '- ignoring\n')
+            else:
+                maxRate = 1 # [zahran] should be 1 to allow using all the bandwidth
+            maxRate_bps = maxRate*bw*1000000
+            maxRates.append(int(maxRate_bps))
+
+            if 'minRate' in qspec:
+                minRate = qspec['minRate']
+                if minRate and (minRate < 0 or minRate > 1 or minRate >= maxRate):
+                    error('Given minRate ', minRate, ' is outside supported range 0..%d' % 1, '- ignoring\n')
+            else:
+                minRate = 0.01 # [zahran] set to 1%
+            minRate_bps = minRate*bw*1000000
+            minRates.append(int(minRate_bps))
+
+        qosMaxRate = bw*1000000
+        #qosminRate = 0
+
+        queuelen = len(queues)
+        self.queuecount += 1
+        print('Create QoS on ' + str(intf) + ' interface \n')
+        cmdstr = 'ovs-vsctl -- set port ' + str(intf) + ' qos=@newqos' + str(self.queuecount) + ' -- --id=@newqos' + \
+                 str(self.queuecount) + ' create qos type=linux-htb other-config:max-rate=' + str(qosMaxRate) #+ ' other-config:min-rate=' + str(qosminRate)
+        for i in range(queuelen):
+            cmdstr += ' queues:' + str(queues[i]) + '=@q' + str(queues[i])
+        for i in range(queuelen):
+            cmdstr += ' -- --id=@q' + str(queues[i]) + ' create queue other-config:max-rate=' + str(maxRates[i]) + \
+                      ' other-config:priority=' + str(priorities[i]) + ' other-config:min-rate=' + str(minRates[i])
+        self.qosUuid.append(node.cmdPrint(cmdstr))
+
+    def __addFlow(self):
+        """Add Flows on temporary switch"""
+        for tsw in self.hiddenSwitchList:
+            for intf in tsw.intfNames():  #[zahran] higly likely not needed 
+                if intf[:5] == 'stemp':   #[zahran] higly likely not needed 
+                    tsw.cmdPrint('ovs-ofctl -O OpenFlow13 add-flow ' + str(tsw) + ' priority=100,ip,in_port=1,actions=output:2')
+                    tsw.cmdPrint('ovs-ofctl -O OpenFlow13 add-flow ' + str(tsw) + ' priority=100,ip,in_port=2,actions=output:1')
+                    break
+
+    def __delQosSwitch(self, switches=None):
+        """Deleting QoS on switches"""
+        if not switches:
+            switches = self.switches
+        for sw in switches:
+            for intf in sw.intfNames():
+                if intf != 'lo' and intf[:5] != 'stemp':
+                    sw.cmdPrint('ovs-vsctl -- clear Port ' + str(intf) + '  qos')
+            if str(sw)[0:5] != 'stemp':
+                for i in self.qosUuid:
+                    sw.cmdPrint('ovs-vsctl destroy qos ' + str(i.split('\n')[0]))
+
+    ############################### Meghana change end ###############################
+
+    def buildFromTopo(self, topo=None):
         """Build mininet from a topology object
            At the end of this function, everything should be connected
            and up."""
@@ -459,56 +622,56 @@
         if self.cleanup:
             pass
 
-        info( '*** Creating network\n' )
+        info('*** Creating network\n')
 
         if not self.controllers and self.controller:
             # Add a default controller
-            info( '*** Adding controller\n' )
+            info('*** Adding controller\n')
             classes = self.controller
-            if not isinstance( classes, list ):
-                classes = [ classes ]
-            for i, cls in enumerate( classes ):
+            if not isinstance(classes, list):
+                classes = [classes]
+            for i, cls in enumerate(classes):
                 # Allow Controller objects because nobody understands partial()
-                if isinstance( cls, Controller ):
-                    self.addController( cls )
+                if isinstance(cls, Controller):
+                    self.addController(cls)
                 else:
-                    self.addController( 'c%d' % i, cls )
+                    self.addController('c%d' % i, cls)
 
-        info( '*** Adding hosts:\n' )
+        info('*** Adding hosts:\n')
         for hostName in topo.hosts():
-            self.addHost( hostName, **topo.nodeInfo( hostName ) )
-            info( hostName + ' ' )
+            self.addHost(hostName, **topo.nodeInfo(hostName))
+            info(hostName + ' ')
 
-        info( '\n*** Adding switches:\n' )
+        info('\n*** Adding switches:\n')
         for switchName in topo.switches():
             # A bit ugly: add batch parameter if appropriate
-            params = topo.nodeInfo( switchName)
-            cls = params.get( 'cls', self.switch )
-            if hasattr( cls, 'batchStartup' ):
-                params.setdefault( 'batch', True )
-            self.addSwitch( switchName, **params )
-            info( switchName + ' ' )
+            params = topo.nodeInfo(switchName)
+            cls = params.get('cls', self.switch)
+            if hasattr(cls, 'batchStartup'):
+                params.setdefault('batch', True)
+            self.addSwitch(switchName, **params)
+            info(switchName + ' ')
 
-        info( '\n*** Adding links:\n' )
+        info('\n*** Adding links:\n')
         for srcName, dstName, params in topo.links(
-                sort=True, withInfo=True ):
-            self.addLink( **params )
-            info( '(%s, %s) ' % ( srcName, dstName ) )
+                sort=True, withInfo=True):
+            self.addLink(**params)
+            info('(%s, %s) ' % (srcName, dstName))
 
-        info( '\n' )
+        info('\n')
 
-    def configureControlNetwork( self ):
+    def configureControlNetwork(self):
         "Control net config hook: override in subclass"
-        raise Exception( 'configureControlNetwork: '
-                         'should be overriden in subclass', self )
+        raise Exception('configureControlNetwork: '
+                        'should be overriden in subclass', self)
 
-    def build( self ):
+    def build(self):
         "Build mininet."
         if self.topo:
-            self.buildFromTopo( self.topo )
+            self.buildFromTopo(self.topo)
         if self.inNamespace:
             self.configureControlNetwork()
-        info( '*** Configuring hosts\n' )
+        info('*** Configuring hosts\n')
         self.configHosts()
         if self.xterms:
             self.startTerms()
@@ -516,100 +679,150 @@
             self.staticArp()
         self.built = True
 
-    def startTerms( self ):
+    def startTerms(self):
         "Start a terminal for each node."
         if 'DISPLAY' not in os.environ:
-            error( "Error starting terms: Cannot connect to display\n" )
+            error("Error starting terms: Cannot connect to display\n")
             return
-        info( "*** Running terms on %s\n" % os.environ[ 'DISPLAY' ] )
+        info("*** Running terms on %s\n" % os.environ['DISPLAY'])
         cleanUpScreens()
-        self.terms += makeTerms( self.controllers, 'controller' )
-        self.terms += makeTerms( self.switches, 'switch' )
-        self.terms += makeTerms( self.hosts, 'host' )
+        self.terms += makeTerms(self.controllers, 'controller')
+        self.terms += makeTerms(self.switches, 'switch')
+        self.terms += makeTerms(self.hosts, 'host')
 
-    def stopXterms( self ):
+    def stopXterms(self):
         "Kill each xterm."
         for term in self.terms:
-            os.kill( term.pid, signal.SIGKILL )
+            os.kill(term.pid, signal.SIGKILL)
         cleanUpScreens()
 
-    def staticArp( self ):
+    def staticArp(self):
         "Add all-pairs ARP entries to remove the need to handle broadcast."
         for src in self.hosts:
             for dst in self.hosts:
                 if src != dst:
-                    src.setARP( ip=dst.IP(), mac=dst.MAC() )
+                    src.setARP(ip=dst.IP(), mac=dst.MAC())
 
-    def start( self ):
+    def start(self):
         "Start controller and switches."
         if not self.built:
             self.build()
-        info( '*** Starting controller\n' )
+        info('*** Starting controller\n')
         for controller in self.controllers:
-            info( controller.name + ' ')
+            info(controller.name + ' ')
             controller.start()
-        info( '\n' )
-        info( '*** Starting %s switches\n' % len( self.switches ) )
+        info('\n')
+        info('*** Starting %s switches\n' % len(self.switches))
         for switch in self.switches:
-            info( switch.name + ' ')
-            switch.start( self.controllers )
+            info(switch.name + ' ')
+            switch.start(self.controllers)
         started = {}
         for swclass, switches in groupby(
-                sorted( self.switches,
-                        key=lambda s: str( type( s ) ) ), type ):
-            switches = tuple( switches )
-            if hasattr( swclass, 'batchStartup' ):
-                success = swclass.batchStartup( switches )
-                started.update( { s: s for s in success } )
-        info( '\n' )
+                sorted(self.switches,
+                       key=lambda s: str(type(s))), type):
+            switches = tuple(switches)
+            if hasattr(swclass, 'batchStartup'):
+                success = swclass.batchStartup(switches)
+                started.update({s: s for s in success})
+        info('\n')
         if self.waitConn:
-            self.waitConnected( self.waitConn )
+            self.waitConnected(self.waitConn)
+
+        ############################### Meghana change start ###############################
+        info('*** Starting %s temporary switches\n' % len(self.hiddenSwitchList))
+        for tswitch in self.hiddenSwitchList:
+            info(tswitch.name + ' ')
+            tswitch.start(self.controllers)
+        tstarted = {}
+        for tswclass, tswitches in groupby(
+                sorted(self.hiddenSwitchList,
+                       key=lambda s: str(type(s))), type):
+            tswitches = tuple(tswitches)
+            if hasattr(tswclass, 'batchStartup'):
+                tsuccess = tswclass.batchStartup(tswitches)
+                tstarted.update({s: s for s in tsuccess})
+
+            info('*** Creating QoS on switch interface ***')
+            for switch in self.switches: #[zahran] should be moved up to typical switch Initialization 
+                if switch.hasQlink == True:
+                    for intf in switch.intfList():
+                        if intf in self.qintf:
+                            self.__qosSwitch(switch, intf)
 
-    def stop( self ):
+            info('*** Add flows on temporary switch interfaces ***')
+            self.__addFlow() 
+
+        ############################### Meghana change end ###############################
+
+    def stop(self):
+        ############################### Meghana change start ###############################
         "Stop the controller(s), switches and hosts"
-        info( '*** Stopping %i controllers\n' % len( self.controllers ) )
+        info('*** Deleting queues created\n')
+        for switch in self.switches:
+            if switch.hasQlink:
+                info('\nDelete QoS on switches\n')
+                self.__delQosSwitch()
+        ############################### Meghana change end ###############################
+
+        info('*** Stopping %i controllers\n' % len(self.controllers))
         for controller in self.controllers:
-            info( controller.name + ' ' )
+            info(controller.name + ' ')
             controller.stop()
-        info( '\n' )
+        info('\n')
         if self.terms:
-            info( '*** Stopping %i terms\n' % len( self.terms ) )
+            info('*** Stopping %i terms\n' % len(self.terms))
             self.stopXterms()
-        info( '*** Stopping %i links\n' % len( self.links ) )
+        info('*** Stopping %i links\n' % len(self.links))
         for link in self.links:
-            info( '.' )
+            info('.')
             link.stop()
-        info( '\n' )
-        info( '*** Stopping %i switches\n' % len( self.switches ) )
+        info('\n')
+        info('*** Stopping %i switches\n' % len(self.switches))
         stopped = {}
         for swclass, switches in groupby(
-                sorted( self.switches,
-                        key=lambda s: str( type( s ) ) ), type ):
-            switches = tuple( switches )
-            if hasattr( swclass, 'batchShutdown' ):
-                success = swclass.batchShutdown( switches )
-                stopped.update( { s: s for s in success } )
+                sorted(self.switches,
+                       key=lambda s: str(type(s))), type):
+            switches = tuple(switches)
+            if hasattr(swclass, 'batchShutdown'):
+                success = swclass.batchShutdown(switches)
+                stopped.update({s: s for s in success})
         for switch in self.switches:
-            info( switch.name + ' ' )
+            info(switch.name + ' ')
             if switch not in stopped:
                 switch.stop()
             switch.terminate()
-        info( '\n' )
-        info( '*** Stopping %i hosts\n' % len( self.hosts ) )
+        ############################### Meghana change start ###############################
+        info('*** Stopping %i temporary switches\n' % len(self.hiddenSwitchList))
+        tstopped = {}
+        for tswclass, tswitches in groupby(
+                sorted(self.hiddenSwitchList,
+                       key=lambda s: str(type(s))), type):
+            tswitches = tuple(tswitches)
+            if hasattr(tswclass, 'batchShutdown'):
+                tsuccess = tswclass.batchShutdown(tswitches)
+                tstopped.update({s: s for s in tsuccess})
+        for tswitch in self.hiddenSwitchList:
+            info(tswitch.name + ' ')
+            if tswitch not in tstopped:
+                tswitch.stop()
+            tswitch.terminate()
+        ############################### Meghana change end ###############################
+        info('\n')
+        info('*** Stopping %i hosts\n' % len(self.hosts))
         for host in self.hosts:
-            info( host.name + ' ' )
+            info(host.name + ' ')
             host.terminate()
-        info( '\n*** Done\n' )
+        info('\n*** Done\n')
 
-    def run( self, test, *args, **kwargs ):
+    def run(self, test, *args, **kwargs):
         "Perform a complete start/test/stop cycle."
         self.start()
-        info( '*** Running test\n' )
-        result = test( *args, **kwargs )
+        info('*** Running test\n')
+        result = test(*args, **kwargs)
         self.stop()
         return result
 
-    def monitor( self, hosts=None, timeoutms=-1 ):
+    def monitor(self, hosts=None, timeoutms=-1):
         """Monitor a set of hosts (or all hosts by default),
            and return their output, a line at a time.
            hosts: (optional) set of hosts to monitor
@@ -618,13 +831,13 @@
         if hosts is None:
             hosts = self.hosts
         poller = select.poll()
-        h1 = hosts[ 0 ]  # so we can call class method fdToNode
+        h1 = hosts[0]  # so we can call class method fdToNode
         for host in hosts:
-            poller.register( host.stdout )
+            poller.register(host.stdout)
         while True:
-            ready = poller.poll( timeoutms )
+            ready = poller.poll(timeoutms)
             for fd, event in ready:
-                host = h1.fdToNode( fd )
+                host = h1.fdToNode(fd)
                 if event & select.POLLIN:
                     line = host.readline()
                     if line is not None:
@@ -637,21 +850,21 @@
     # Probably we should create a tests.py for them
 
     @staticmethod
-    def _parsePing( pingOutput ):
+    def _parsePing(pingOutput):
         "Parse ping output and return packets sent, received."
         # Check for downed link
         if 'connect: Network is unreachable' in pingOutput:
             return 1, 0
         r = r'(\d+) packets transmitted, (\d+)( packets)? received'
-        m = re.search( r, pingOutput )
+        m = re.search(r, pingOutput)
         if m is None:
-            error( '*** Error: could not parse ping output: %s\n' %
-                   pingOutput )
+            error('*** Error: could not parse ping output: %s\n' %
+                  pingOutput)
             return 1, 0
-        sent, received = int( m.group( 1 ) ), int( m.group( 2 ) )
+        sent, received = int(m.group(1)), int(m.group(2))
         return sent, received
 
-    def ping( self, hosts=None, timeout=None ):
+    def ping(self, hosts=None, timeout=None):
         """Ping between all specified hosts.
            hosts: list of hosts
            timeout: time to wait for a response, as string
@@ -662,71 +875,71 @@
         ploss = None
         if not hosts:
             hosts = self.hosts
-            output( '*** Ping: testing ping reachability\n' )
+            output('*** Ping: testing ping reachability\n')
         for node in hosts:
-            output( '%s -> ' % node.name )
+            output('%s -> ' % node.name)
             for dest in hosts:
                 if node != dest:
                     opts = ''
                     if timeout:
                         opts = '-W %s' % timeout
                     if dest.intfs:
-                        result = node.cmd( 'ping -c1 %s %s' %
-                                           (opts, dest.IP()) )
-                        sent, received = self._parsePing( result )
+                        result = node.cmd('ping -c1 %s %s' %
+                                          (opts, dest.IP()))
+                        sent, received = self._parsePing(result)
                     else:
                         sent, received = 0, 0
                     packets += sent
                     if received > sent:
-                        error( '*** Error: received too many packets' )
-                        error( '%s' % result )
-                        node.cmdPrint( 'route' )
-                        exit( 1 )
+                        error('*** Error: received too many packets')
+                        error('%s' % result)
+                        node.cmdPrint('route')
+                        exit(1)
                     lost += sent - received
-                    output( ( '%s ' % dest.name ) if received else 'X ' )
-            output( '\n' )
+                    output(('%s ' % dest.name) if received else 'X ')
+            output('\n')
         if packets > 0:
             ploss = 100.0 * lost / packets
             received = packets - lost
-            output( "*** Results: %i%% dropped (%d/%d received)\n" %
-                    ( ploss, received, packets ) )
+            output("*** Results: %i%% dropped (%d/%d received)\n" %
+                   (ploss, received, packets))
         else:
             ploss = 0
-            output( "*** Warning: No packets sent\n" )
+            output("*** Warning: No packets sent\n")
         return ploss
 
     @staticmethod
-    def _parsePingFull( pingOutput ):
+    def _parsePingFull(pingOutput):
         "Parse ping output and return all data."
         errorTuple = (1, 0, 0, 0, 0, 0)
         # Check for downed link
         r = r'[uU]nreachable'
-        m = re.search( r, pingOutput )
+        m = re.search(r, pingOutput)
         if m is not None:
             return errorTuple
         r = r'(\d+) packets transmitted, (\d+)( packets)? received'
-        m = re.search( r, pingOutput )
+        m = re.search(r, pingOutput)
         if m is None:
-            error( '*** Error: could not parse ping output: %s\n' %
-                   pingOutput )
+            error('*** Error: could not parse ping output: %s\n' %
+                  pingOutput)
             return errorTuple
-        sent, received = int( m.group( 1 ) ), int( m.group( 2 ) )
+        sent, received = int(m.group(1)), int(m.group(2))
         r = r'rtt min/avg/max/mdev = '
         r += r'(\d+\.\d+)/(\d+\.\d+)/(\d+\.\d+)/(\d+\.\d+) ms'
-        m = re.search( r, pingOutput )
+        m = re.search(r, pingOutput)
         if m is None:
             if received == 0:
                 return errorTuple
-            error( '*** Error: could not parse ping output: %s\n' %
-                   pingOutput )
+            error('*** Error: could not parse ping output: %s\n' %
+                  pingOutput)
             return errorTuple
-        rttmin = float( m.group( 1 ) )
-        rttavg = float( m.group( 2 ) )
-        rttmax = float( m.group( 3 ) )
-        rttdev = float( m.group( 4 ) )
+        rttmin = float(m.group(1))
+        rttavg = float(m.group(2))
+        rttmax = float(m.group(3))
+        rttdev = float(m.group(4))
         return sent, received, rttmin, rttavg, rttmax, rttdev
 
-    def pingFull( self, hosts=None, timeout=None ):
+    def pingFull(self, hosts=None, timeout=None):
         """Ping between all specified hosts and return all data.
            hosts: list of hosts
            timeout: time to wait for a response, as string
@@ -736,69 +949,69 @@
         all_outputs = []
         if not hosts:
             hosts = self.hosts
-            output( '*** Ping: testing ping reachability\n' )
+            output('*** Ping: testing ping reachability\n')
         for node in hosts:
-            output( '%s -> ' % node.name )
+            output('%s -> ' % node.name)
             for dest in hosts:
                 if node != dest:
                     opts = ''
                     if timeout:
                         opts = '-W %s' % timeout
-                    result = node.cmd( 'ping -c1 %s %s' % (opts, dest.IP()) )
-                    outputs = self._parsePingFull( result )
+                    result = node.cmd('ping -c1 %s %s' % (opts, dest.IP()))
+                    outputs = self._parsePingFull(result)
                     sent, received, rttmin, rttavg, rttmax, rttdev = outputs
-                    all_outputs.append( (node, dest, outputs) )
-                    output( ( '%s ' % dest.name ) if received else 'X ' )
-            output( '\n' )
-        output( "*** Results: \n" )
+                    all_outputs.append((node, dest, outputs))
+                    output(('%s ' % dest.name) if received else 'X ')
+            output('\n')
+        output("*** Results: \n")
         for outputs in all_outputs:
             src, dest, ping_outputs = outputs
             sent, received, rttmin, rttavg, rttmax, rttdev = ping_outputs
-            output( " %s->%s: %s/%s, " % (src, dest, sent, received ) )
-            output( "rtt min/avg/max/mdev %0.3f/%0.3f/%0.3f/%0.3f ms\n" %
-                    (rttmin, rttavg, rttmax, rttdev) )
+            output(" %s->%s: %s/%s, " % (src, dest, sent, received))
+            output("rtt min/avg/max/mdev %0.3f/%0.3f/%0.3f/%0.3f ms\n" %
+                   (rttmin, rttavg, rttmax, rttdev))
         return all_outputs
 
-    def pingAll( self, timeout=None ):
+    def pingAll(self, timeout=None):
         """Ping between all hosts.
            returns: ploss packet loss percentage"""
-        return self.ping( timeout=timeout )
+        return self.ping(timeout=timeout)
 
-    def pingPair( self ):
+    def pingPair(self):
         """Ping between first two hosts, useful for testing.
            returns: ploss packet loss percentage"""
-        hosts = [ self.hosts[ 0 ], self.hosts[ 1 ] ]
-        return self.ping( hosts=hosts )
+        hosts = [self.hosts[0], self.hosts[1]]
+        return self.ping(hosts=hosts)
 
-    def pingAllFull( self ):
+    def pingAllFull(self):
         """Ping between all hosts.
            returns: ploss packet loss percentage"""
         return self.pingFull()
 
-    def pingPairFull( self ):
+    def pingPairFull(self):
         """Ping between first two hosts, useful for testing.
            returns: ploss packet loss percentage"""
-        hosts = [ self.hosts[ 0 ], self.hosts[ 1 ] ]
-        return self.pingFull( hosts=hosts )
+        hosts = [self.hosts[0], self.hosts[1]]
+        return self.pingFull(hosts=hosts)
 
     @staticmethod
-    def _parseIperf( iperfOutput ):
+    def _parseIperf(iperfOutput):
         """Parse iperf output and return bandwidth.
            iperfOutput: string
            returns: result string"""
         r = r'([\d\.]+ \w+/sec)'
-        m = re.findall( r, iperfOutput )
+        m = re.findall(r, iperfOutput)
         if m:
             return m[-1]
         else:
             # was: raise Exception(...)
-            error( 'could not parse iperf output: ' + iperfOutput )
+            error('could not parse iperf output: ' + iperfOutput)
             return ''
 
     # XXX This should be cleaned up
 
-    def iperf( self, hosts=None, l4Type='TCP', udpBw='10M', fmt=None,
-               seconds=5, port=5001):
+    def iperf(self, hosts=None, l4Type='TCP', udpBw='10M', fmt=None,
+              seconds=5, port=5001):
         """Run iperf between two hosts.
            hosts: list of hosts; if None, uses first and last hosts
            l4Type: string, one of [ TCP, UDP ]
@@ -810,125 +1023,125 @@
            note: send() is buffered, so client rate can be much higher than
            the actual transmission rate; on an unloaded system, server
            rate should be much closer to the actual receive rate"""
-        hosts = hosts or [ self.hosts[ 0 ], self.hosts[ -1 ] ]
-        assert len( hosts ) == 2
+        hosts = hosts or [self.hosts[0], self.hosts[-1]]
+        assert len(hosts) == 2
         client, server = hosts
-        output( '*** Iperf: testing', l4Type, 'bandwidth between',
-                client, 'and', server, '\n' )
-        server.cmd( 'killall -9 iperf' )
+        output('*** Iperf: testing', l4Type, 'bandwidth between',
+               client, 'and', server, '\n')
+        server.cmd('killall -9 iperf')
         iperfArgs = 'iperf -p %d ' % port
         bwArgs = ''
         if l4Type == 'UDP':
             iperfArgs += '-u '
             bwArgs = '-b ' + udpBw + ' '
         elif l4Type != 'TCP':
-            raise Exception( 'Unexpected l4 type: %s' % l4Type )
+            raise Exception('Unexpected l4 type: %s' % l4Type)
         if fmt:
             iperfArgs += '-f %s ' % fmt
-        server.sendCmd( iperfArgs + '-s' )
+        server.sendCmd(iperfArgs + '-s')
         if l4Type == 'TCP':
-            if not waitListening( client, server.IP(), port ):
-                raise Exception( 'Could not connect to iperf on port %d'
-                                 % port )
-        cliout = client.cmd( iperfArgs + '-t %d -c ' % seconds +
-                             server.IP() + ' ' + bwArgs )
-        debug( 'Client output: %s\n' % cliout )
+            if not waitListening(client, server.IP(), port):
+                raise Exception('Could not connect to iperf on port %d'
+                                % port)
+        cliout = client.cmd(iperfArgs + '-t %d -c ' % seconds +
+                            server.IP() + ' ' + bwArgs)
+        debug('Client output: %s\n' % cliout)
         servout = ''
         # We want the last *b/sec from the iperf server output
         # for TCP, there are two of them because of waitListening
         count = 2 if l4Type == 'TCP' else 1
-        while len( re.findall( '/sec', servout ) ) < count:
-            servout += server.monitor( timeoutms=5000 )
+        while len(re.findall('/sec', servout)) < count:
+            servout += server.monitor(timeoutms=5000)
         server.sendInt()
         servout += server.waitOutput()
-        debug( 'Server output: %s\n' % servout )
-        result = [ self._parseIperf( servout ), self._parseIperf( cliout ) ]
+        debug('Server output: %s\n' % servout)
+        result = [self._parseIperf(servout), self._parseIperf(cliout)]
         if l4Type == 'UDP':
-            result.insert( 0, udpBw )
-        output( '*** Results: %s\n' % result )
+            result.insert(0, udpBw)
+        output('*** Results: %s\n' % result)
         return result
 
-    def runCpuLimitTest( self, cpu, duration=5 ):
+    def runCpuLimitTest(self, cpu, duration=5):
         """run CPU limit test with 'while true' processes.
         cpu: desired CPU fraction of each host
         duration: test duration in seconds (integer)
         returns a single list of measured CPU fractions as floats.
         """
         pct = cpu * 100
-        info( '*** Testing CPU %.0f%% bandwidth limit\n' % pct )
+        info('*** Testing CPU %.0f%% bandwidth limit\n' % pct)
         hosts = self.hosts
-        cores = int( quietRun( 'nproc' ) )
+        cores = int(quietRun('nproc'))
         # number of processes to run a while loop on per host
-        num_procs = int( ceil( cores * cpu ) )
+        num_procs = int(ceil(cores * cpu))
         pids = {}
         for h in hosts:
-            pids[ h ] = []
-            for _core in range( num_procs ):
-                h.cmd( 'while true; do a=1; done &' )
-                pids[ h ].append( h.cmd( 'echo $!' ).strip() )
+            pids[h] = []
+            for _core in range(num_procs):
+                h.cmd('while true; do a=1; done &')
+                pids[h].append(h.cmd('echo $!').strip())
         outputs = {}
         time = {}
         # get the initial cpu time for each host
         for host in hosts:
-            outputs[ host ] = []
-            with open( '/sys/fs/cgroup/cpuacct/%s/cpuacct.usage' %
-                       host, 'r' ) as f:
-                time[ host ] = float( f.read() )
-        for _ in range( duration ):
-            sleep( 1 )
+            outputs[host] = []
+            with open('/sys/fs/cgroup/cpuacct/%s/cpuacct.usage' %
+                      host, 'r') as f:
+                time[host] = float(f.read())
+        for _ in range(duration):
+            sleep(1)
             for host in hosts:
-                with open( '/sys/fs/cgroup/cpuacct/%s/cpuacct.usage' %
-                           host, 'r' ) as f:
-                    readTime = float( f.read() )
-                outputs[ host ].append( ( ( readTime - time[ host ] )
-                                        / 1000000000 ) / cores * 100 )
-                time[ host ] = readTime
+                with open('/sys/fs/cgroup/cpuacct/%s/cpuacct.usage' %
+                          host, 'r') as f:
+                    readTime = float(f.read())
+                outputs[host].append(((readTime - time[host])
+                                      / 1000000000) / cores * 100)
+                time[host] = readTime
         for h, pids in pids.items():
             for pid in pids:
-                h.cmd( 'kill -9 %s' % pid )
+                h.cmd('kill -9 %s' % pid)
         cpu_fractions = []
         for _host, outputs in outputs.items():
             for pct in outputs:
-                cpu_fractions.append( pct )
-        output( '*** Results: %s\n' % cpu_fractions )
+                cpu_fractions.append(pct)
+        output('*** Results: %s\n' % cpu_fractions)
         return cpu_fractions
 
     # BL: I think this can be rewritten now that we have
     # a real link class.
-    def configLinkStatus( self, src, dst, status ):
+    def configLinkStatus(self, src, dst, status):
         """Change status of src <-> dst links.
            src: node name
            dst: node name
            status: string {up, down}"""
         if src not in self.nameToNode:
-            error( 'src not in network: %s\n' % src )
+            error('src not in network: %s\n' % src)
         elif dst not in self.nameToNode:
-            error( 'dst not in network: %s\n' % dst )
+            error('dst not in network: %s\n' % dst)
         else:
-            src = self.nameToNode[ src ]
-            dst = self.nameToNode[ dst ]
-            connections = src.connectionsTo( dst )
-            if len( connections ) == 0:
-                error( 'src and dst not connected: %s %s\n' % ( src, dst) )
+            src = self.nameToNode[src]
+            dst = self.nameToNode[dst]
+            connections = src.connectionsTo(dst)
+            if len(connections) == 0:
+                error('src and dst not connected: %s %s\n' % (src, dst))
             for srcIntf, dstIntf in connections:
-                result = srcIntf.ifconfig( status )
+                result = srcIntf.ifconfig(status)
                 if result:
-                    error( 'link src status change failed: %s\n' % result )
-                result = dstIntf.ifconfig( status )
+                    error('link src status change failed: %s\n' % result)
+                result = dstIntf.ifconfig(status)
                 if result:
-                    error( 'link dst status change failed: %s\n' % result )
+                    error('link dst status change failed: %s\n' % result)
 
-    def interact( self ):
+    def interact(self):
         "Start network and run our simple CLI."
         self.start()
-        result = CLI( self )
+        result = CLI(self)
         self.stop()
         return result
 
     inited = False
 
     @classmethod
-    def init( cls ):
+    def init(cls):
         "Initialize Mininet"
         if cls.inited:
             return
@@ -937,8 +1150,7 @@
         cls.inited = True
 
 
-class MininetWithControlNet( Mininet ):
-
+class MininetWithControlNet(Mininet):
     """Control network support:
 
        Create an explicit control network. Currently this is only
@@ -965,44 +1177,44 @@
           control network which every node's control interface is
           attached to."""
 
-    def configureControlNetwork( self ):
+    def configureControlNetwork(self):
         "Configure control network."
         self.configureRoutedControlNetwork()
 
     # We still need to figure out the right way to pass
     # in the control network location.
 
-    def configureRoutedControlNetwork( self, ip='192.168.123.1',
-                                       prefixLen=16 ):
+    def configureRoutedControlNetwork(self, ip='192.168.123.1',
+                                      prefixLen=16):
         """Configure a routed control network on controller and switches.
            For use with the user datapath only right now."""
-        controller = self.controllers[ 0 ]
-        info( controller.name + ' <->' )
+        controller = self.controllers[0]
+        info(controller.name + ' <->')
         cip = ip
-        snum = ipParse( ip )
+        snum = ipParse(ip)
         for switch in self.switches:
-            info( ' ' + switch.name )
-            link = self.link( switch, controller, port1=0 )
+            info(' ' + switch.name)
+            link = self.link(switch, controller, port1=0)
             sintf, cintf = link.intf1, link.intf2
             switch.controlIntf = sintf
             snum += 1
-            while snum & 0xff in [ 0, 255 ]:
+            while snum & 0xff in [0, 255]:
                 snum += 1
-            sip = ipStr( snum )
-            cintf.setIP( cip, prefixLen )
-            sintf.setIP( sip, prefixLen )
-            controller.setHostRoute( sip, cintf )
-            switch.setHostRoute( cip, sintf )
-        info( '\n' )
-        info( '*** Testing control network\n' )
+            sip = ipStr(snum)
+            cintf.setIP(cip, prefixLen)
+            sintf.setIP(sip, prefixLen)
+            controller.setHostRoute(sip, cintf)
+            switch.setHostRoute(cip, sintf)
+        info('\n')
+        info('*** Testing control network\n')
         while not cintf.isUp():
-            info( '*** Waiting for', cintf, 'to come up\n' )
-            sleep( 1 )
+            info('*** Waiting for', cintf, 'to come up\n')
+            sleep(1)
         for switch in self.switches:
             while not sintf.isUp():
-                info( '*** Waiting for', sintf, 'to come up\n' )
-                sleep( 1 )
-            if self.ping( hosts=[ switch, controller ] ) != 0:
-                error( '*** Error: control network test failed\n' )
-                exit( 1 )
-        info( '\n' )
+                info('*** Waiting for', sintf, 'to come up\n')
+                sleep(1)
+            if self.ping(hosts=[switch, controller]) != 0:
+                error('*** Error: control network test failed\n')
+                exit(1)
+        info('\n')
diff -Naur mininet/node.py mininet/node.py
--- mininet/node.py	2022-02-01 13:22:08.423979000 +0100
+++ mininet/node.py	2022-01-05 10:38:02.000000000 +0100
@@ -1092,6 +1092,7 @@
         self._uuids = []  # controller UUIDs
         self.batch = batch
         self.commands = []  # saved commands for batch startup
+        self.hasQlink = False   # Added by Meghana 
 
     @classmethod
     def setup( cls ):
diff -Naur mininet/util.py mininet/util.py
--- mininet/util.py	2022-02-01 13:22:08.423979000 +0100
+++ mininet/util.py	2022-01-05 10:02:14.000000000 +0100
@@ -323,7 +323,17 @@
             if intf.link:
                 intfs = [ intf.link.intf1, intf.link.intf2 ]
                 intfs.remove( intf )
-                output( intfs[ 0 ] )
+                # *********** To hide stemp switch from net command   Meghana
+                if str(intfs[0])[0:5] == 'stemp':
+                    stemp_node = intfs[0].node
+                    stemp_intfs = stemp_node.intfList()
+                    stemp_intfs.remove(intfs[0])
+                    stemp2_link = stemp_intfs[ 1 ].link
+                    stemp2_link_intfs = [stemp2_link.intf1, stemp2_link.intf2]
+                    stemp2_link_intfs.remove(stemp_intfs[ 1 ])
+                    output(stemp2_link_intfs[0])
+                else:
+                    output( intfs[ 0 ] )
             else:
                 output( ' ' )
 
